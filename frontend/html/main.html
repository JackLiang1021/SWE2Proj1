<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Program Graph — vis-network</title>
  <style>
    html, body { height: 100%; margin: 0; }
    #net { width: 100vw; height: 100vh; overflow: hidden; }
    #hud {
      position: absolute; z-index: 5; top: 12px; left: 12px;
      background: rgba(255,255,255,0.92); padding: 10px 12px; border-radius: 8px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; box-shadow: 0 2px 10px rgba(0,0,0,.1);
    }
    #hud input { width: 160px; }
    #status { font-size: 12px; color: #444; margin-top: 6px; }
    #legend { font-size: 12px; margin-top: 6px; color: #333; }
    .swatch { display: inline-block; width: 10px; height: 10px; margin-right: 6px; border-radius: 2px; vertical-align: middle; }
  </style>
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
</head>
<body>
  <div id="hud">
    <div>
      <label>Base:</label>
      <input id="baseUrl" value="http://localhost:8080">
    </div>
    <div style="margin-top:6px;">
      <label>Program:</label>
      <input id="programCode" value="CS">
      <label style="margin-left:8px;">Year:</label>
      <input id="catalogYear" value="2024">
      <button id="reload" style="margin-left:8px;">Load</button>
    </div>
    <div id="legend">
      <span class="swatch" style="background:#e9f5ff; border:1px solid #8ac6ff;"></span> Course (unlocked)
      &nbsp;&nbsp;<span class="swatch" style="background:#fff7e6; border:1px solid #ffd28a;"></span> Course used as prerequisite
      &nbsp;&nbsp;<span class="swatch" style="background:#d7f7de; border:1px solid #66c487;"></span> Completed
      &nbsp;&nbsp;<span class="swatch" style="background:#eee; border:1px solid #bbb;"></span> Locked (has unmet prereqs)
    </div>
    <div id="status">Ready.</div>
  </div>
  <div id="net"></div>

  <script>
    const qs = new URLSearchParams(location.search);
    const byId = id => document.getElementById(id);
    if (qs.get('base'))    byId('baseUrl').value = qs.get('base');
    if (qs.get('program')) byId('programCode').value = qs.get('program');
    if (qs.get('year'))    byId('catalogYear').value = qs.get('year');

    const nodes = new vis.DataSet([]);
    const edges = new vis.DataSet([]);

    const network = new vis.Network(
      document.getElementById('net'),
      { nodes, edges },
      {
        physics: { stabilization: true, solver: "forceAtlas2Based" },
        interaction: { hover: true, selectable: true },
        edges: { arrows: "to", smooth: { type: "dynamic" } },
        nodes: { shape: "dot", size: 16, font: { face: "Inter, system-ui, sans-serif" } }
      }
    );

    function setStatus(msg) { byId('status').textContent = msg; }

    const COLOR = {
      program: { background: "#2d7ff9", border: "#1b5fd6", hbg:"#2d7ff9", hbr:"#123f9c", font:"#fff" },
      course:  { background: "#e9f5ff", border: "#8ac6ff", hbg:"#d6eeff", hbr:"#5eb4ff" },
      prereq:  { background: "#fff7e6", border: "#ffd28a", hbg:"#ffefd1", hbr:"#ffbe5e" },
      locked:  { background: "#eeeeee", border: "#bbbbbb" },
      done:    { background: "#d7f7de", border: "#66c487", hbg:"#c9f1d2", hbr:"#4ab173" }
    };

    const completed = new Set();
    const unlocked  = new Set();
    const courseInGraph = new Set();
    const prereqsOf = new Map();
    const dependentsOf = new Map();
    let programNodeId = null;
    let programName = null;

    function upsertNode(id, data) {
      const existing = nodes.get(id);
      if (!existing) nodes.add({ id, ...data });
      else nodes.update({ id, ...data });
    }

    function upsertEdge(idOrData) {
      const key = idOrData.id || `${idOrData.from}->${idOrData.to}`;
      if (!edges.get(key)) edges.add({ id: key, ...idOrData });
    }

    async function fetchJSON(url) {
      const res = await fetch(url, { credentials: "omit" });
      if (!res.ok) throw new Error(`${res.status} ${res.statusText} for ${url}`);
      return res.json();
    }

    function courseNodeId(code) { return `course:${code}`; }

    function styleProgramNodeDefault() {
      const label = programName ? `${programName}` : `Program: ${byId('programCode').value.trim()}`;
      upsertNode(programNodeId, {
        label,
        title: `All courses lead here`,
        color: {
          background: COLOR.program.background,
          border:      COLOR.program.border,
          highlight: { background: COLOR.program.hbg, border: COLOR.program.hbr }
        },
        font: { color: COLOR.program.font, bold: { color: COLOR.program.font } },
        size: 24
      });
    }

    function styleProgramNodeCompleted() {
      const label = programName ? `${programName} (Completed)` : `Program Completed`;
      upsertNode(programNodeId, {
        label,
        title: `All requirements completed`,
        color: {
          background: COLOR.done.background,
          border:      COLOR.done.border,
          highlight: { background: COLOR.done.hbg, border: COLOR.done.hbr }
        },
        font: { color: "#114b20", bold: { color: "#114b20" } },
        size: 26
      });
    }

    function setNodeLocked(code) {
      const id = courseNodeId(code);
      if (!nodes.get(id)) return;
      nodes.update({ id, color: { background: COLOR.locked.background, border: COLOR.locked.border } });
    }

    function setNodeUnlocked(code, wasPrereq) {
      const id = courseNodeId(code);
      if (!nodes.get(id)) return;
      const base = wasPrereq ? COLOR.prereq : COLOR.course;
      nodes.update({ id, color: {
        background: base.background, border: base.border,
        highlight: { background: base.hbg, border: base.hbr }
      }});
    }

    function setNodeCompleted(code) {
      const id = courseNodeId(code);
      if (!nodes.get(id)) return;
      nodes.update({ id, color: {
        background: COLOR.done.background, border: COLOR.done.border,
        highlight: { background: COLOR.done.hbg, border: COLOR.done.hbr }
      }});
    }

    function updateProgramCompletionState() {
      const total = courseInGraph.size;
      const done = completed.size;
      if (total > 0 && done === total) styleProgramNodeCompleted();
      else styleProgramNodeDefault();
    }

    function recomputeUnlocks() {
      unlocked.clear();
      for (const code of courseInGraph) {
        const prereqs = prereqsOf.get(code) || new Set();
        const allMet = [...prereqs].every(p => completed.has(p));
        const isPrereqNode = (dependentsOf.get(code) || new Set()).size > 0;
        if (allMet) {
          unlocked.add(code);
          setNodeUnlocked(code, isPrereqNode);
        } else {
          setNodeLocked(code);
        }
        if (completed.has(code)) setNodeCompleted(code);
      }
      updateProgramCompletionState();
    }

    function toggleComplete(code) {
      if (!unlocked.has(code)) return;
      if (completed.has(code)) completed.delete(code);
      else completed.add(code);
      recomputeUnlocks();
    }

    async function buildGraph(base, programCode, year) {
      nodes.clear(); edges.clear();
      completed.clear(); unlocked.clear();
      courseInGraph.clear(); prereqsOf.clear(); dependentsOf.clear();
      setStatus('Loading program, versions, and groups…');

      programNodeId = `program:${programCode}`;
      programName = null;

      try {
        const prog = await fetchJSON(`${base}/programs/${encodeURIComponent(programCode)}`);
        programName = prog && prog.name ? prog.name : null;
      } catch (e) {}

      styleProgramNodeDefault();

      const groupsUrl = `${base}/programs/${encodeURIComponent(programCode)}/versions/${encodeURIComponent(year)}/groups`;
      const groups = await fetchJSON(groupsUrl);

      const maybePrereq = new Set();
      for (const g of groups) {
        const options = Array.isArray(g.courseOptions) ? g.courseOptions : [];
        for (const c of options) {
          if (!c || !c.code) continue;
          const code = c.code;
          courseInGraph.add(code);
          const id = courseNodeId(code);
          if (!nodes.get(id)) {
            upsertNode(id, {
              label: code,
              title: `${c.name || code}\nCredits: ${c.credits ?? '—'}`,
              color: {
                background: COLOR.course.background, border: COLOR.course.border,
                highlight: { background: COLOR.course.hbg, border: COLOR.course.hbr }
              }
            });
            upsertEdge({ from: id, to: programNodeId });
          }
        }
      }

      setStatus(`Loaded ${courseInGraph.size} course(s). Fetching prerequisites…`);
      const prereqPromises = [];
      for (const code of courseInGraph) {
        const url = `${base}/courses/${encodeURIComponent(code)}/prerequisites`;
        prereqPromises.push(
          fetchJSON(url).then(prereqs => {
            const presentPrereqs = new Set();
            for (const p of prereqs || []) {
              if (!p || !p.code) continue;
              const pCode = p.code;
              if (courseInGraph.has(pCode)) {
                presentPrereqs.add(pCode);
                maybePrereq.add(pCode);
                const pid = courseNodeId(pCode);
                if (!nodes.get(pid)) {
                  upsertNode(pid, {
                    label: pCode,
                    title: `${p.name || pCode}\nCredits: ${p.credits ?? '—'}`,
                    color: {
                      background: COLOR.prereq.background, border: COLOR.prereq.border,
                      highlight: { background: COLOR.prereq.hbg, border: COLOR.prereq.hbr }
                    }
                  });
                }
                upsertEdge({ from: pid, to: courseNodeId(code) });
                if (!dependentsOf.has(pCode)) dependentsOf.set(pCode, new Set());
                dependentsOf.get(pCode).add(code);
              }
            }
            prereqsOf.set(code, presentPrereqs);
          }).catch(() => {
            prereqsOf.set(code, new Set());
          })
        );
      }
      await Promise.all(prereqPromises);

      for (const pCode of maybePrereq) {
        if (completed.has(pCode)) continue;
        const id = courseNodeId(pCode);
        if (nodes.get(id)) {
          nodes.update({ id, color: {
            background: COLOR.prereq.background, border: COLOR.prereq.border,
            highlight: { background: COLOR.prereq.hbg, border: COLOR.prereq.hbr }
          }});
        }
      }

      for (const code of courseInGraph) if (!prereqsOf.has(code)) prereqsOf.set(code, new Set());
      recomputeUnlocks();

      network.off("click");
      network.on("click", params => {
        if (!params.nodes || params.nodes.length === 0) return;
        const id = params.nodes[0];
        if (!id.startsWith("course:")) return;
        const code = id.slice("course:".length);
        if (!courseInGraph.has(code)) return;
        if (!unlocked.has(code)) {
          setStatus(`"${code}" is locked — complete its prerequisites first.`);
          return;
        }
        toggleComplete(code);
        const nextLocked = [...courseInGraph].filter(c => !unlocked.has(c) && !completed.has(c)).length;
        setStatus(`Toggled "${code}" ${completed.has(code) ? 'complete' : 'reset'}. ${unlocked.size} unlocked, ${completed.size} complete, ${nextLocked} locked.`);
      });

      setStatus('Loaded. Click unlocked nodes to mark complete; this will unlock their dependents.');
    }

    byId('reload').addEventListener('click', () => {
      const base = byId('baseUrl').value.trim();
      const program = byId('programCode').value.trim();
      const year = byId('catalogYear').value.trim();
      buildGraph(base, program, year);
    });

    buildGraph(byId('baseUrl').value.trim(), byId('programCode').value.trim(), byId('catalogYear').value.trim());
  </script>
</body>
</html>
