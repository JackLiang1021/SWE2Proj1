<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Degree Planner</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      }
      #hud {
        position: sticky;
        top: 0;
        z-index: 10;
        background: #fff;
        padding: 12px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.06);
        display: flex;
        gap: 12px;
        align-items: center;
        flex-wrap: wrap;
      }
      #planner {
        padding: 16px;
        display: grid;
        gap: 16px;
      }
      .course.completed {
        background: #f0fdf4;
        border-color: #86efac;
        cursor: default;
      }
      .tags {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        margin-top: 4px;
      }
      .tag {
        padding: 2px 6px;
        border-radius: 999px;
        background: #eef2ff;
        color: #3730a3;
        font-size: 11px;
        border: 1px solid #c7d2fe;
      }
      #groupsPanel {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .groupChip {
        border: 1px solid #e5e7eb;
        border-radius: 999px;
        padding: 4px 8px;
        background: #fff;
        font-size: 12px;
      }
      .groupChip.done {
        background: #ecfdf5;
        border-color: #34d399;
        color: #065f46;
      }
      .semester {
        border: 1px solid #e5e7eb;
        border-radius: 12px;
        padding: 12px;
        background: #fafafa;
      }
      .semester-header {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 8px;
        margin-bottom: 8px;
      }
      .semester-title {
        font-weight: 700;
      }
      .semester-credits {
        font-size: 12px;
        color: #555;
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 8px;
      }
      .course {
        border: 1px solid #d1d5db;
        background: #fff;
        padding: 8px;
        border-radius: 10px;
        cursor: pointer;
        user-select: none;
        display: grid;
        gap: 4px;
      }
      .course.locked {
        opacity: 0.55;
        cursor: not-allowed;
      }
      .course.selected {
        outline: 2px solid #2563eb;
        box-shadow: 0 0 0 2px #bfdbfe inset;
      }
      .course .code {
        font-weight: 700;
      }
      .course .name {
        color: #374151;
        font-size: 13px;
        line-height: 1.2;
      }
      .course .meta {
        font-size: 12px;
        color: #6b7280;
      }
      .controls {
        display: flex;
        gap: 8px;
        margin-top: 10px;
      }
      button {
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid #d1d5db;
        background: #fff;
        cursor: pointer;
      }
      button.primary {
        background: #2563eb;
        color: #fff;
        border-color: #1d4ed8;
      }
      button.danger {
        background: #ef4444;
        color: #fff;
        border-color: #dc2626;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .preview {
        border: 1px dashed #c7d2fe;
        background: #f5f7ff;
      }
      .done-banner {
        background: #d1fae5;
        border: 1px solid #34d399;
        color: #065f46;
        padding: 10px;
        border-radius: 10px;
      }
      .pill {
        padding: 2px 8px;
        border-radius: 999px;
        background: #eef2ff;
        color: #3730a3;
        font-size: 12px;
      }

      #tab_container a {
        display: inline-block;
        padding: 6px 14px;
        border-radius: 6px;
        color: #333;
        text-decoration: none;
        font-weight: 500;
        background-color: #f5f5f7;
        transition: all 0.2s ease-in-out;
      }

      #tab_container a:hover {
        background-color: #e3e3e8;
        color: #000;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      #tab_container a:active {
        background-color: #d1d1d6;
        transform: translateY(1px);
      }
    </style>
  </head>
  <body>
    <div id="hud">
      <div>
        <label>Base:</label>
        <input id="baseUrl" value="http://localhost:8080" />
      </div>
      <div>
        <label>Program:</label>
        <input id="programCode" value="CS" />
        <label style="margin-left: 8px">Year:</label>
        <input id="catalogYear" value="2024" />
        <button id="reload">Load</button>
      </div>
      <div id="groupsPanel"></div>
      <div>
        <label>StudentId:</label>
        <input id="studentId" value="1" />
      </div>
      <div>
        <progress
          id="progress"
          value="0"
          max="100"
          style="width: 260px; height: 16px"
        ></progress>
        <span id="label">0 / 0</span>
      </div>
      <div id="tab_container"><a href="graph.html">Graph</a></div>
      <button
        id="logoutBtn"
        style="
          margin-left: 8px;
          background: #ef4444;
          color: #fff;
          border: 1px solid #dc2626;
          border-radius: 8px;
          padding: 6px 10px;
          cursor: pointer;
        "
      >
        Log out
      </button>

      <div id="status" class="pill">Ready.</div>
    </div>

    <div id="planner"></div>
    <script type="module">
      import { DegreeApi } from "api.js";
      import { invertDependencyMap } from "models.js";
      import { BASE_URL } from "config.js";

      const logoutBtn = document.getElementById("logoutBtn");
      if (logoutBtn) {
        logoutBtn.addEventListener("click", () => {
          localStorage.removeItem("student");
          window.location.href = "/";
        });
      }

      function getSession() {
        try {
          const s = JSON.parse(localStorage.getItem("student") || "null");
          if (!s || !s.studentId || !s.baseUrl) return null;
          return s;
        } catch {
          return null;
        }
      }
      async function jget(url) {
        const r = await fetch(url, { credentials: "omit" });
        if (!r.ok) throw new Error(`${r.status} ${r.statusText} for ${url}`);
        return r.json();
      }

      const byId = (id) => document.getElementById(id);
      const session = getSession();
      if (!session) {
        location.href = "index.html";
        throw new Error("No session");
      }

      byId("baseUrl").value = BASE_URL;
      const api = new DegreeApi(BASE_URL);

      (function lockInputs() {
        const sid = byId("studentId");
        if (sid) {
          sid.value = String(session.studentId);
          sid.disabled = true;
          sid.style.opacity = 0.6;
        }

        const lock = (id) => {
          const el = byId(id);
          if (el) {
            el.disabled = true;
            el.style.opacity = 0.6;
          }
        };
        lock("programCode");
        lock("catalogYear");
      })();

      const CREDIT_CAP = 19;

      const state = {
        snapshot: null,
        depMap: {},
        inverse: {},
        completed: new Set(),
        semesters: [],
        current: { index: 0, candidates: [], selected: new Set(), preview: [] },
        credits: { total: 0, required: 0 },
        groups: [],
      };

      async function addCompletedToBackend(studentId, codes) {
        if (!codes || codes.length === 0) return;
        const url = `${BASE_URL}/students/${encodeURIComponent(
          studentId
        )}/completed`;
        const res = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "omit",
          body: JSON.stringify(codes),
        });
        if (!res.ok)
          throw new Error(`${res.status} ${res.statusText} adding completions`);
        return res.json();
      }
      async function removeCompletedFromBackend(studentId, code) {
        const url = `${BASE_URL}/students/${encodeURIComponent(
          studentId
        )}/completed/${encodeURIComponent(code)}`;
        const res = await fetch(url, { method: "DELETE", credentials: "omit" });
        if (!res.ok && res.status !== 204)
          throw new Error(`${res.status} ${res.statusText} removing ${code}`);
      }

      function creditsOf(code) {
        const c = state.snapshot.courses.get(code);
        return c ? c.credits || 0 : 0;
      }
      function nameOf(code) {
        const c = state.snapshot.courses.get(code);
        return c ? c.name || code : code;
      }
      function sumCredits(iter) {
        let n = 0;
        for (const code of iter) n += creditsOf(code);
        return n;
      }
      function groupsForCourse(code) {
        const out = [];
        for (const g of state.groups)
          if ((g.courseOptions || []).some((opt) => opt.code === code))
            out.push(g);
        return out;
      }
      function setStatus(msg) {
        byId("status").textContent = msg;
      }
      function updateProgressBar() {
        const bar = byId("progress");
        const label = byId("label");
        bar.max = state.credits.required;
        bar.value = Math.min(state.credits.total, bar.max);
        label.textContent = `${bar.value} / ${bar.max}`;
      }
      function computeGroupProgress() {
        const earnedByGroup = new Map();
        for (const g of state.groups) earnedByGroup.set(g.id, 0);
        for (const code of state.completed) {
          const c = state.snapshot.courses.get(code);
          if (!c) continue;
          for (const g of state.groups) {
            const inGroup = (g.courseOptions || []).some(
              (opt) => opt.code === code
            );
            if (!inGroup) continue;
            const cur = earnedByGroup.get(g.id);
            if (cur >= g.minRequired) continue;
            earnedByGroup.set(
              g.id,
              Math.min(g.minRequired, cur + (c.credits || 0))
            );
            break;
          }
        }
        return earnedByGroup;
      }
      function renderGroupsPanel() {
        const panel = byId("groupsPanel");
        panel.innerHTML = "";
        const earnedByGroup = computeGroupProgress();
        for (const g of state.groups) {
          const earned = earnedByGroup.get(g.id) || 0;
          const chip = document.createElement("span");
          chip.className =
            "groupChip" + (earned >= g.minRequired ? " done" : "");
          chip.textContent = `${g.name}: ${earned}/${g.minRequired}`;
          panel.appendChild(chip);
        }
      }
      function allGroupsSatisfied() {
        const earnedByGroup = computeGroupProgress();
        for (const g of state.groups)
          if ((earnedByGroup.get(g.id) || 0) < g.minRequired) return false;
        return true;
      }
      function availableGivenCompleted() {
        const result = [];
        for (const code of state.snapshot.courses.keys()) {
          if (state.completed.has(code)) continue;
          const pres = state.depMap[code] || [];
          const met = pres.every((p) => state.completed.has(p));
          if (met) result.push(code);
        }
        return result;
      }
      function unionDependentsOf(codes) {
        const out = new Set();
        for (const code of codes) {
          const deps = state.inverse[code] || [];
          for (const d of deps) {
            if (!state.completed.has(d)) out.add(d);
          }
        }
        return Array.from(out);
      }

      function makeCourseCard(
        code,
        { locked = false, selected = false, completed = false } = {}
      ) {
        const div = document.createElement("div");
        div.className =
          "course" +
          (locked ? " locked" : "") +
          (selected ? " selected" : "") +
          (completed ? " completed" : "");
        div.dataset.code = code;
        const groupTags = groupsForCourse(code)
          .map((g) => `<span class="tag">${g.name}</span>`)
          .join("");
        div.innerHTML = `
      <div class="code">${code}</div>
      <div class="name">${nameOf(code)}</div>
      <div class="meta">${creditsOf(code)} credits</div>
      <div class="tags">${groupTags}</div>`;
        return div;
      }

      function renderCompletedSemester() {
        if (state.completed.size === 0) return;
        const wrapper = document.createElement("div");
        wrapper.className = "semester";
        const header = document.createElement("div");
        header.className = "semester-header";
        const total = sumCredits(state.completed);
        header.innerHTML = `<div><span class="semester-title">Completed so far</span></div><div class="semester-credits">Count: ${state.completed.size}, Credits: ${total}</div>`;
        const grid = document.createElement("div");
        grid.className = "grid";
        for (const code of Array.from(state.completed).sort())
          grid.appendChild(
            makeCourseCard(code, { locked: true, completed: true })
          );
        wrapper.append(header, grid);
        byId("planner").appendChild(wrapper);
      }

      function renderSemesterBox(index, candidates) {
        const wrapper = document.createElement("div");
        wrapper.className = "semester";
        wrapper.dataset.semester = String(index + 1);
        const selectedCredits = () => sumCredits(state.current.selected);
        const header = document.createElement("div");
        header.className = "semester-header";
        header.innerHTML = `<div><span class="semester-title">Semester ${
          index + 1
        }</span></div>
                        <div class="semester-credits">Selected: <span id="sc-${index}">0</span> / ${CREDIT_CAP} credits</div>`;
        const grid = document.createElement("div");
        grid.className = "grid";
        const controls = document.createElement("div");
        controls.className = "controls";
        const btnConfirm = document.createElement("button");
        btnConfirm.className = "primary";
        btnConfirm.textContent = "Confirm Selection";
        btnConfirm.disabled = true;
        const btnClear = document.createElement("button");
        btnClear.textContent = "Clear";
        const btnUndo = document.createElement("button");
        btnUndo.className = "danger";
        btnUndo.textContent = "Undo this semester";
        btnUndo.disabled = true;
        controls.append(btnConfirm, btnClear, btnUndo);
        wrapper.append(header, grid, controls);

        const preview = document.createElement("div");
        preview.className = "semester preview";
        const pHeader = document.createElement("div");
        pHeader.className = "semester-header";
        pHeader.innerHTML = `<div class="semester-title">Next up (dependents)</div><div class="semester-credits"></div>`;
        const pGrid = document.createElement("div");
        pGrid.className = "grid";
        preview.append(pHeader, pGrid);
        const planner = byId("planner");
        planner.append(wrapper, preview);

        const refreshButtons = () => {
          const sc = selectedCredits();
          byId(`sc-${index}`).textContent = String(sc);
          btnConfirm.disabled = sc === 0 || sc > CREDIT_CAP;
        };
        const refreshPreview = () => {
          const depends = unionDependentsOf(state.current.selected);
          pGrid.innerHTML = "";
          for (const code of depends) {
            const pres = state.depMap[code] || [];
            const met = pres.every(
              (p) => state.completed.has(p) || state.current.selected.has(p)
            );
            pGrid.appendChild(makeCourseCard(code, { locked: !met }));
          }
        };

        grid.innerHTML = "";
        for (const code of candidates) {
          if (state.completed.has(code)) continue;
          const pres = state.depMap[code] || [];
          const met = pres.every((p) => state.completed.has(p));
          const card = makeCourseCard(code, {
            locked: !met,
            selected: state.current.selected.has(code),
          });
          card.addEventListener("click", () => {
            if (card.classList.contains("locked")) return;
            const willAdd = !state.current.selected.has(code);
            const newTotal =
              selectedCredits() +
              (willAdd ? creditsOf(code) : -creditsOf(code));
            if (willAdd && newTotal > CREDIT_CAP) {
              setStatus(`Credit cap ${CREDIT_CAP} would be exceeded`);
              return;
            }
            if (willAdd) state.current.selected.add(code);
            else state.current.selected.delete(code);
            card.classList.toggle("selected");
            refreshButtons();
            refreshPreview();
          });
          grid.appendChild(card);
        }

        btnClear.addEventListener("click", () => {
          state.current.selected.clear();
          for (const el of grid.querySelectorAll(".course.selected"))
            el.classList.remove("selected");
          refreshButtons();
          refreshPreview();
        });

        btnConfirm.addEventListener("click", async () => {
          const picked = Array.from(state.current.selected);
          if (picked.length === 0) return;
          const sid = session.studentId;

          try {
            await addCompletedToBackend(sid, picked);
          } catch (e) {
            console.error(e);
            setStatus(`Failed to save to server. Nothing was changed.`);
            return;
          }

          for (const code of picked) state.completed.add(code);
          state.credits.total += sumCredits(picked);
          updateProgressBar();
          renderGroupsPanel();

          for (const el of grid.querySelectorAll(".course"))
            el.classList.add("locked");
          btnConfirm.disabled = true;
          btnClear.disabled = true;

          const remaining = state.current.candidates.filter(
            (c) => !state.current.selected.has(c) && !state.completed.has(c)
          );
          const unlockedNow = availableGivenCompleted().filter(
            (c) => !state.completed.has(c)
          );
          const next = Array.from(new Set([...remaining, ...unlockedNow]));

          state.semesters.push({
            index,
            codes: picked,
            prevCandidates: [...state.current.candidates],
            wrapperEl: wrapper,
            previewEl: preview,
          });
          document
            .querySelectorAll("button[data-undo]")
            .forEach((b) => (b.disabled = true));
          btnUndo.disabled = false;
          btnUndo.dataset.undo = "true";

          if (
            allGroupsSatisfied() &&
            state.credits.total >= state.credits.required
          ) {
            const done = document.createElement("div");
            done.id = "doneBanner";
            done.className = "done-banner";
            done.textContent =
              "ðŸŽ“ All requirement groups satisfied and total credits reached. Program complete!";
            byId("planner").appendChild(done);
            setStatus("Finished.");
            return;
          }

          state.current.index += 1;
          state.current.candidates = next;
          state.current.selected = new Set();
          renderSemesterBox(state.current.index, state.current.candidates);
          setStatus(
            `Semester ${state.current.index} planned. Continue selecting.`
          );
        });

        btnUndo.addEventListener("click", async () => {
          const last = state.semesters[state.semesters.length - 1];
          if (!last || last.index !== index) {
            setStatus("You can only undo the most recent semester.");
            return;
          }

          const done = document.getElementById("doneBanner");
          if (done) done.remove();
          const sid = session.studentId;
          try {
            for (const code of last.codes)
              await removeCompletedFromBackend(sid, code);
          } catch (e) {
            console.error(e);
            setStatus("Failed to undo on server. No changes made.");
            return;
          }

          for (const code of last.codes) state.completed.delete(code);
          state.credits.total -= sumCredits(last.codes);
          if (state.credits.total < 0) state.credits.total = 0;
          updateProgressBar();
          renderGroupsPanel();

          if (last.wrapperEl?.parentNode)
            last.wrapperEl.parentNode.removeChild(last.wrapperEl);
          if (last.previewEl?.parentNode)
            last.previewEl.parentNode.removeChild(last.previewEl);

          state.semesters.pop();
          state.current.index = index;
          state.current.candidates = last.prevCandidates.filter(
            (c) => !state.completed.has(c)
          );
          state.current.selected = new Set();
          renderSemesterBox(state.current.index, state.current.candidates);
          setStatus("Last semester undone.");
        });

        btnUndo.setAttribute("data-undo", "true");
        refreshButtons();
        refreshPreview();
      }

      async function boot() {
        setStatus("Loadingâ€¦");
        // Get program & year from THIS studentâ€™s progress
        const prog = await jget(
          `${BASE_URL}/students/${encodeURIComponent(
            session.studentId
          )}/progress`
        );
        const programCode = prog.program;
        const year = prog.catalogYear;

        if (byId("programCode")) byId("programCode").value = programCode;
        if (byId("catalogYear")) byId("catalogYear").value = year;

        const snapshot = await api.loadVersionSnapshot(programCode, year);

        let student = null;
        try {
          student = await api.getStudent(session.studentId);
        } catch (e) {
          console.warn("Student fetch failed:", e);
        }

        state.snapshot = snapshot;
        state.depMap = snapshot.depMap;
        state.inverse = invertDependencyMap(snapshot.depMap);
        state.groups = snapshot.groups;
        state.credits.required = snapshot.version.requiredCredits;
        state.completed.clear();
        state.semesters = [];

        if (student && Array.isArray(student.completedCourses)) {
          for (const c of student.completedCourses) {
            if (snapshot.courses.has(c.code)) state.completed.add(c.code);
          }
        }
        state.credits.total = Array.from(state.completed).reduce(
          (s, code) => s + (snapshot.courses.get(code)?.credits || 0),
          0
        );

        byId("planner").innerHTML = "";
        updateProgressBar();
        renderGroupsPanel();
        renderCompletedSemester();

        const initial = availableGivenCompleted();
        state.current.index = 0;
        state.current.selected = new Set();
        state.current.candidates = initial;
        renderSemesterBox(0, initial);
        setStatus(
          "Ready. Select up to 19 credits and confirm to create the next semester."
        );
      }

      byId("reload").addEventListener("click", boot);
      boot();
    </script>
  </body>
</html>
